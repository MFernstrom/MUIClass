<?xml version="1.0" encoding="ISO-8859-1"?>
<fpdoc-descriptions>
<package name="MUIClass">

<!--
  ====================================================================
    MUIClass.Area
  ====================================================================
-->

<module name="MUIClass.Area">
<short>Area and some derived classes</short>
<descr>
</descr>

<!-- uses unit Visibility: default -->
<element name="System">
<short></short>
</element>

<!-- uses unit Visibility: default -->
<element name="Classes">
<short></short>
</element>

<!-- uses unit Visibility: default -->
<element name="SysUtils">
<short></short>
</element>

<!-- uses unit Visibility: default -->
<element name="fgl">
<short></short>
</element>

<!-- uses unit Visibility: default -->
<element name="Math">
<short></short>
</element>

<!-- uses unit Visibility: default -->
<element name="Exec">
<short></short>
</element>

<!-- uses unit Visibility: default -->
<element name="Utility">
<short></short>
</element>

<!-- uses unit Visibility: default -->
<element name="AmigaDOS">
<short></short>
</element>

<!-- uses unit Visibility: default -->
<element name="Intuition">
<short></short>
</element>

<!-- uses unit Visibility: default -->
<element name="agraphics">
<short></short>
</element>

<!-- uses unit Visibility: default -->
<element name="icon">
<short></short>
</element>

<!-- uses unit Visibility: default -->
<element name="mui">
<short></short>
</element>

<!-- uses unit Visibility: default -->
<element name="muihelper">
<short></short>
</element>

<!-- uses unit Visibility: default -->
<element name="tagsparamshelper">
<short></short>
</element>

<!-- uses unit Visibility: default -->
<element name="MUIClass.Base">
<short></short>
</element>

<!-- uses unit Visibility: default -->
<element name="MUIClass.Window">
<short></short>
</element>

<!-- class Visibility: default -->
<element name="TSpecDesc">
<short>Helper class to set Image descriptors.</short>
<descr>
  Image Descriptors can be set in different ways, mostly as string
  but also as Integer constant. This class helps with setting up this.
</descr>
<errors>
</errors>
<seealso>
  <link id="#MUIClass.MUIClass.Area.TMUIArea.Background">TMUIArea.Background</link>
  <link id="#MUIClass.MUIClass.Image.TMUIImage.Spec">TMUIImage.Spec</link>
</seealso>
</element>

<!-- record type Visibility: default -->
<element name="TBubble">
<short>Black box structure for a Bubble help</short>
<descr>
</descr>
<seealso>
  <link id="#MUIClass.MUIClass.Area.TMUIArea.CreateBubble">TMUIArea.CreateBubble()</link>
  <link id="#MUIClass.MUIClass.Area.TMUIArea.DeleteBubble">TMUIArea.DeleteBubble()</link>
   <link id="TMUIArea.DeleteAllBubbles">DeleteAllBubbles()</link>
  <link id="#MUIClass.MUIClass.Area.PBubble">PBubble</link>
</seealso>
</element>

<!-- pointer type Visibility: default -->
<element name="PBubble">
<short>Handle for a Bubble Help</short>
<descr>
</descr>
<seealso>
  <link id="#MUIClass.MUIClass.Area.TMUIArea.CreateBubble">TMUIArea.CreateBubble()</link>
  <link id="#MUIClass.MUIClass.Area.TMUIArea.DeleteBubble">TMUIArea.DeleteBubble()</link>
   <link id="TMUIArea.DeleteAllBubbles">DeleteAllBubbles()</link>
</seealso>
</element>

<!-- specialized class type Visibility: default -->
<element name="TBubbleList">
<short>Type to keep a list of open Bubbles to close them after application is terminated</short>
<descr>
  The Bubbles are not automatically destroyed by MUI. Therefore we destroy them on the end of Application.
</descr>
</element>

<!-- record type Visibility: default -->
<element name="TMUIRGB">
<short>Type for a typical MUI RGB Color with three LongWords to describe the color.</short>
<descr>
  Attention: a white color will be $ffffffff, $ffffffff, $ffffffff (in contrast a $ff, $ff, $ff would be still black)
</descr>
</element>

<!-- variable Visibility: default -->
<element name="TMUIRGB.Red">
<short>Red color part in 32 bit (0..$ffffffff)</short>
</element>

<!-- variable Visibility: default -->
<element name="TMUIRGB.Green">
<short>Green color part in 32 bit (0..$ffffffff)</short>
</element>

<!-- variable Visibility: default -->
<element name="TMUIRGB.Blue">
<short>Blue color part in 32 bit (0..$ffffffff)</short>
</element>

<!-- pointer type Visibility: default -->
<element name="PMUIRGB">
<short>Pointer to a list of MUI RGB color with three LongWords for every color</short>
</element>

<!-- class Visibility: default -->
<element name="TMUIArea">
<short>Super class for every other MUI class except windows and applications</short>
<descr>
  <p>
  Area class is a super class for every other MUI class
  except windows and applications. It holds information
  about an objects current position, size and weight
  and manages frames, fonts and backgrounds.</p>
  <p>
  Additionally, area class handles the user input. By
  setting an objects <link id="#MUIClass.MUIClass.Area.TMUIArea.InputMode">MUIA_InputMode</link>, you can make it
  behave like a button or like a toggle gadget. That's
  why MUI doesn't offer an extra button class. A button
  is simply a text object with a raised frame and a relverify
  input mode. Since especially group class is a subclass
  of area, you can create rather complex buttons consisting
  of many other display elements.</p>
</descr>
</element>

<!-- procedure Visibility: protected -->
<element name="TMUIArea.AfterCreateObject">
<short>Started after the MUI Object is created to connect events.</short>
<descr>Will be called by <link id="TMUIArea.CreateObject">CreateObject</link> there is no reason to call it yourself.</descr>
</element>

<!-- procedure Visibility: protected -->
<element name="TMUIArea.BeforeCloseWindow">
<short>Called before the window gets closed or the application get terminated to clean some contents</short>
</element>

<!-- procedure Visibility: protected -->
<element name="TMUIArea.GetCreateTags">
<short>Get the properties of this class as TagList to create the MUI Object</short>
<descr>Will be called by <link id="TMUIArea.CreateObject">CreateObject</link> there is no reason to call it yourself.
</descr>
</element>

<!-- argument Visibility: default -->
<element name="TMUIArea.GetCreateTags.ATagList">
<short>TagList to add the properties for this class.</short>
</element>

<!-- property Visibility: protected -->
<element name="TMUIArea.FillArea">
<short>Prevent MUI of drawing the background (Init only)</short>
<descr>
  Set this to False if you are a custom class and dont want area class to
  clear your background during the DoSuperMethod() in your
  draw method. Note that if you set this, your draw method
  is responsible for filling every pixel of your objects
  rectangle, otherwise some display trash will remain there.
</descr>
</element>

<!-- constructor Visibility: public -->
<element name="TMUIArea.Create">
<short>Create the class and init the properties</short>
</element>

<!-- destructor Visibility: public -->
<element name="TMUIArea.Destroy">
<short>Destroy the class, if the MUI object is still alive it will be disconnected and destroyed as well.</short>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIArea.CreateObject">
<short>Create the MUI object.</short>
<descr>This will be called by the Parent class, usually you do not need to call this yourself.
</descr>
</element>

<!-- function Visibility: public -->
<element name="TMUIArea.CreateBubble">
<short>Create a MUI Bubble</short>
<descr>
  <p>
  Together with <link id="TMUIArea.DeleteBubble">DeleteBubble()</link>, this method provides an
  interface for MUIs bubble mechanism. Applications can use
  bubbles for their own purpose, e.g. for indicating error
  conditions on certain gadgets.</p>
  <p>
  CreateBubble() creates a bubble at the specified
  coordinates with the specified (textual) contents. It
  returns a bubble "handle" that has to be passed to
  <link id="TMUIArea.DeleteBubble">DeleteBubble()</link> when the bubble shall disappear.</p>
  <p>
  There's no limitation on the number of bubbles, you can create
  lots of them at a time if you wish. Also, these custom bubbles
  are completely independant of MUI's bubble help system and won't
  disappear automatically when the mouse is moved.</p>
  <p>
  Note that bubbles will only show up when the object in question
  is visible. Otherwise CreateBubble() returns nil. You are
  responsible for deleting the bubble <b>before</b> the object get's
  invisible. Good place to remove a custom bubble is e.g. the
  Hide method of your object.</p>
  <p>Defined flags:</p>
  <dl>
    <dt>MUIV_CreateBubble_DontHidePointer</dt><dd>prevents MUI from hiding the mouse pointer when displaying
            the help bubble. It is recommended that you always set this,
            unless your bubble is meant to disappear as soon as there
            is some user input.</dd>
  </dl>
</descr>
<seealso>
  <link id="TMUIArea.DeleteBubble">DeleteBubble()</link>
  <link id="TMUIArea.DeleteAllBubbles">DeleteAllBubbles()</link>
</seealso>
</element>

<!-- function result Visibility: public -->
<element name="TMUIArea.CreateBubble.Result">
<short>Bubble Handle use to close the bubble again with: <link id="TMUIArea.DeleteBubble">DeleteBubble()</link></short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIArea.CreateBubble.x">
<short>window related x position to open the bubble</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIArea.CreateBubble.y">
<short>window related y position to open the bubble</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIArea.CreateBubble.Txt">
<short>Text to show inside the bubble</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIArea.CreateBubble.Flags">
<short>Flags for the bubble, see table</short>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIArea.DeleteBubble">
<short>Deletes a previously created Bubble</short>
<descr><p>
  Together with <link id="TMUIArea.CreateBubble">CreateBubble()</link>, this method provides an
  interface for MUIs bubble mechanism. Applications can use
  bubbles for their own purpose, e.g. for indicating error
  conditions on certain gadgets.</p>
<p>
  DeleteBubble deletes a bubble that was previously
  created with <link id="TMUIArea.CreateBubble">CreateBubble()</link>. Note that bubbles have to
  be deleted before an object get's invisible!</p>
</descr>
<seealso>
  <link id="TMUIArea.CreateBubble">CreateBubble()</link>
  <link id="TMUIArea.DeleteAllBubbles">DeleteAllBubbles()</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TMUIArea.DeleteBubble.Bubble">
<short>Bubble handle returned by  <link id="TMUIArea.CreateBubble">CreateBubble()</link></short>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIArea.DeleteAllBubbles">
<short>Delete all bubbles which are created with  <link id="TMUIArea.CreateBubble">CreateBubble()</link> for this object</short>
<descr>
  The object remembers the open bubbles, with this method you can call all bubbles opened on this object.
  Note: all the bubble handles become invalid in this moment.
</descr>
<seealso>
   <link id="TMUIArea.CreateBubble">CreateBubble()</link>
   <link id="TMUIArea.DeleteBubble">DeleteBubble()</link>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TMUIArea.LeftEdge">
<short>Current left position of the object</short>
<descr>
<p>
You can use this to read the current position and
dimension of an object, if you e.g. need it to pop
up some requester below.</p>
<p>
Of course, this attribute is only valid when the
parent window of the object is currently open.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TMUIArea.TopEdge">
<short>Current top position of the object</short>
<descr>
<p>
You can use this to read the current position and
dimension of an object, if you e.g. need it to pop
up some requester below.</p>
<p>
Of course, this attribute is only valid when the
parent window of the object is currently open.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TMUIArea.RightEdge">
<short>Current Right edge of the object</short>
<descr>
<p>
You can use this to read the current position and
dimension of an object, if you e.g. need it to pop
up some requester below.</p>
<p>
Of course, this attribute is only valid when the
parent window of the object is currently open.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TMUIArea.BottomEdge">
<short>Current bottom edge of the object</short>
<descr>
<p>
You can use this to read the current position and
dimension of an object, if you e.g. need it to pop
up some requester below.</p>
<p>
Of course, this attribute is only valid when the
parent window of the object is currently open.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TMUIArea.Height">
<short>Current Height of the object</short>
<descr>
<p>
You can use this to read the current position and
dimension of an object, if you e.g. need it to pop
up some requester below.</p>
<p>
Of course, this attribute is only valid when the
parent window of the object is currently open.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TMUIArea.Width">
<short>Current Width of the object</short>
<descr>
<p>
You can use this to read the current position and
dimension of an object, if you e.g. need it to pop
up some requester below.</p>
<p>
Of course, this attribute is only valid when the
parent window of the object is currently open.</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TMUIArea.Pressed">
<short>Mouse press state of the object</short>
<descr>
  <p>
  The Pressed attribute of a gadget is triggered
  by some user action, depending on the input mode:</p>
  <dl>
  <dt>MUIV_InputMode_RelVerify</dt><dd><ul><li>set when lmb is pressed.</li>
           <li>cleared when lmb is released and the mouse
             is still over the gadget (otherwise it will
             be cleared too, but without triggering a
             notification event).</li></ul></dd>
  <dt>MUIV_InputMode_Immediate</dt><dd>undefined, use <link id="TMUIArea.Selected">Selected</link> for this.</dd>
  <dt>MUIV_InputMode_Toggle</dt><dd>undefined, use <link id="TMUIArea.Selected">Selected</link> for this.</dd>
  <dt></dt><dd></dd>
  </dl>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TMUIArea.Window">
<short>Pointer to the Intution structure PWindow</short>
<descr>
<p>
This attribute can be used to get a pointer to the
intuition window structure of the parent window
ot the object. This pointer could e.g. be used
in calls to asl.library.</p>
<p>
The result is only valid when the window is opened.</p>
</descr>
<seealso>
  <link id="TMUIArea.WindowObject">WindowObject</link>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TMUIArea.WindowObject">
<short>Get the Window object the object is placed in</short>
<descr>
  You can obtain a pointer to the window object
  that some gadget belongs to by using this attribute.
  Useful mainly within Events if you do not want
  to deal with global variables.
</descr>
</element>

<!-- property Visibility: published -->
<element name="TMUIArea.Background">
<short>[i] Adjust the background for an object.</short>
<descr>
<p>
Every MUI object has its own background setting.
The background is displayed "behind" the actual
object contents, e.g. behind a the text of a
text object or behind the image of an image object.</p>
<p>
This attribute takes the same values as MUIA_Image_Spec,
please refer to autodocs of image class for a complete
description.</p>
<p>
An object without a specific background setting will
inherit the pattern from its parent group. The default
background for a window and many other background
patterns are adjustable with the preferences program.</p>
<p>
Only a few MUII_* tags make sense as background.</p>
<p>Important are:</p>
<dl>
  <dt>MUII_ButtonBack</dt><dd>You have to set this when you create a button gadget. Thus, your button will be displayed in the users preferred style.</dd>
  <dt>MUII_TextBack</dt><dd>Set this when you create a text object with a TextFrame, e.g. some kind of status line. Do *not* use MUII_TextBack for simple text without frame (e.g. gadget labels).</dd>
  <dt>MUII_BACKGROUND,
        MUII_SHADOW,
        MUII_SHINE,
        MUII_FILL,
        MUII_SHADOWBACK,
        MUII_SHADOWFILL,
        MUII_SHADOWSHINE,
        MUII_FILLBACK,
        MUII_FILLSHINE,
        MUII_SHINEBACK,
        MUII_SHINEBACK2</dt><dd>One of MUI's predefined pattern. These are not
           configurable by the user and will always look the
           same.</dd>
</dl>
</descr>
</element>

<!-- property Visibility: published -->
<element name="TMUIArea.ControlChar">
<short>Define a shortcut for the object</short>
<descr>
<p>Pressing the control char will have the same effect
as pressing return if the object was active.</p>
<p>
This can be used to create old style key shortcuts.
 </p>
<p>Note: Using an uppercase control char will force the user to press shift.</p>
</descr>
</element>

<!-- property Visibility: published -->
<element name="TMUIArea.CycleChain">
<short>Add the item to cycle chain</short>
<descr>
Set to one to add the object to the cycle chain. (can navigate with TAB through the items in the chain)
</descr>
</element>

<!-- property Visibility: published -->
<element name="TMUIArea.Disabled">
<short>Disable the item for user input and grey it out</short>
<descr>
<p>
Disable or enable a gadget. Setting this attribute
causes a gadget to become disabled, it gets a ghost
pattern and doesn't respond to user input any longer.</p>
<p>
Disabled gadgets cannot be activated with the TAB key.</p>
<p>
Using Disable on a group of objects will disable
all objects within that group.</p>
</descr>
</element>

<!-- property Visibility: published -->
<element name="TMUIArea.Draggable">
<short>Enable Drag'n'Drop for this object.</short>
<descr>
Set this if you want the complete object to be
dragable for Drag'n'Drop operations.
</descr>
</element>

<!-- property Visibility: published -->
<element name="TMUIArea.Dropable">
<short>Make the item as a drop destination</short>
<descr>
  Only objects with this attribute set to True will be asked
  if they want to become an active Drag'n'Drop destination
  at all. Though this attribute defaults to True, this doesn't
  mean that every object automatically acepts Drag'nDrop actions,
  because the DragQuery method is answered False when
  it arrives at area class.
</descr>
</element>

<!-- property Visibility: published -->
<element name="TMUIArea.FixHeight">
<short>[i] Give your object a fixed pixel height.</short>
<descr>
This property is absolutely not needed in a general MUI application
and only present for emergency situations. Please think twice before using it!
</descr>
</element>

<!-- property Visibility: published -->
<element name="TMUIArea.FixHeightTxt">
<short>[i] Give your object a fixed pixel height. Defined by a text height</short>
<descr>
The height
will match the height of the given string. This property is
absolutely not needed in a general MUI application
and only present for emergency situations. Please
think twice before using it!
</descr>
</element>

<!-- property Visibility: published -->
<element name="TMUIArea.FixWidth">
<short>[i] Give your object a fixed pixel width.</short>
<descr>
This property is absolutely not needed in a general MUI application
and only present for emergency situations. Please think twice before using it!
</descr>
</element>

<!-- property Visibility: published -->
<element name="TMUIArea.FixWidthTxt">
<short>[i] Give your object a fixed pixel width. Defined by a text width</short>
<descr>
  The Width
will match the width of the given string. This property is
absolutely not needed in a general MUI application
and only present for emergency situations. Please
think twice before using it!
</descr>
</element>

<!-- property Visibility: published -->
<element name="TMUIArea.Font">
<short>[i] Define the Font for the item</short>
<descr>
<p>Every MUI object can have its own font, just set it with
this tag. Objects without an explicit font setting will
inherit it from their parent group.</p>
<p>
You normally won't need to open a font yourself, just
use one of the predefined values to get a font from
the users preferences.</p>
<p>Special Inputs:</p>
<p><b>MUIV_Font_Inherit,
MUIV_Font_Normal,
MUIV_Font_List,
MUIV_Font_Tiny,
MUIV_Font_Fixed,
MUIV_Font_Title,
MUIV_Font_Big,
MUIV_Font_Button,
MUIV_Font_Slider,
MUIV_Font_Gauge</b></p>
</descr>
</element>

<!-- property Visibility: published -->
<element name="TMUIArea.Frame">
<short>[i] Define a frame for the item.</short>
<descr><p>
Since area class
is a superclass for all elements in a window, you can
assign frames to every object you wish.</p>
<p>
You don't adjust the style of your frame directly,
instead you only specify a type:</p>
<dl>
  <dt>MUIV_Frame_Button</dt><dd>for standard buttons with text in it.</dd>
  <dt>MUIV_Frame_ImageButton</dt><dd>for small buttons with images, e.g. the arrows of a scrollbar.</dd>
  <dt>MUIV_Frame_Text</dt><dd>for a text field, e.g. a status line display.</dd>
  <dt>MUIV_Frame_String</dt><dd>for a string gadget.</dd>
  <dt>MUIV_Frame_ReadList</dt><dd>for a read only list.</dd>
  <dt>MUIV_Frame_InputList</dt><dd>for a list that handles input (has a cursor).</dd>
  <dt>MUIV_Frame_Prop</dt><dd>for proportional gadgets.</dd>
  <dt>MUIV_Frame_Group</dt><dd> for groups.</dd>
</dl>
<p>How the frame is going to look is adjustable via the
preferences program.</p>
<p>
Four spacing values belong to each frame that tell
MUI how many pixels should be left free between the
frame and its contents. These spacing values are also
user adjustable as long as you don't override them
with one of <link id="TMUIArea.InnerLeft">InnerLeft</link>, <link id="TMUIArea.InnerRight">InnerRight</link>,
<link id="TMUIArea.InnerTop">InnerTop</link> or <link id="TMUIArea.InnerBottom">InnerBottom</link>.</p>
</descr>
<seealso>
  <link id="TMUIArea.InnerLeft">InnerLeft</link>
  <link id="TMUIArea.InnerRight">InnerRight</link>
  <link id="TMUIArea.InnerTop">InnerTop</link>
  <link id="TMUIArea.InnerBottom">InnerBottom</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIArea.FramePhantomHoriz">
<short>[i] Hide the horizontal frame part</short>
<descr>
<p>Setting this to True causes the specified frame to be
a horizontal phantom frame. The frame will not appear
but its vertical components (frame height, inner
top and inner bottom spacing) will be used to calculate
positions and dimensions (horizontal components are
treated as 0).</p>
<p>
This is extremely useful for a correct labeling of objects.
You would e.g. label a string gadget by using a text object
with a phantom string frame. Thus, the label text will
be always on the same vertical position as the string
gadget text, no matter what spacing values the user
configured.</p>
</descr>
</element>

<!-- property Visibility: published -->
<element name="TMUIArea.FrameTitle">
<short>Define a frame title text</short>
<descr>
<p>This tag identifies a text string that will be displayed
centered in the top line of a frame. This can become
handy if you want to name groups of objects.</p>
<p>
You may not use FrameTitle without defining
a <link id="TMUIArea.Frame">Frame</link>.</p>
</descr>
<seealso>
  <link id="TMUIArea.Frame">Frame</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIArea.HorizDisappear">
<short>Set horizontal disappear level</short>
<descr>
<p>Objects with a disappear level disappear automatically
when their parent window gets too small to display them.
Use this for things that make your GUI look nicer
(e.g. Imagery) but are not absolutely necessary.</p>
<p>
By using disappearing objects, you can make nice GUIs
which still work on crappy 640x200 screens.</p>
<p>
You can give horizontal or vertical disappear levels
to objects which are used for horizontal or vertical
layout calculations respectively.</p>
<p>
Objects with a small disappear level disappear before
objects with a big disappear level.
</p>
</descr>
<seealso>
  <link id="TMUIArea.VertDisappear">VertDisappear</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIArea.VertDisappear">
<short>Set vertical disappear level</short>
<descr>
<p>Objects with a disappear level disappear automatically
when their parent window gets too small to display them.
Use this for things that make your GUI look nicer
(e.g. Imagery) but are not absolutely necessary.</p>
<p>
By using disappearing objects, you can make nice GUIs
which still work on crappy 640x200 screens.</p>
<p>
You can give horizontal or vertical disappear levels
to objects which are used for horizontal or vertical
layout calculations respectively.</p>
<p>
Objects with a small disappear level disappear before
objects with a big disappear level.
</p>
</descr>
<seealso>
  <link id="TMUIArea.HorizDisappear">HorizDisappear</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIArea.HorizWeight">
<short>Adjust the horizontal weight of an object.</short>
<descr>
  Usually
  you can simply use <link id="TMUIArea.Weight">Weight</link> instead of this tag
  but in some two-dimensional groups it may become
  handy to have different horizontal and vertical
  weights.
</descr>
<seealso>
  <link id="TMUIArea.Weight">Weight</link>
  <link id="TMUIArea.VertWeight">VertWeight</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIArea.VertWeight">
<short>Adjust the vertical weight of an object.</short>
<descr>
  Usually
  you can simply use <link id="TMUIArea.Weight">Weight</link> instead of this tag
  but in some two-dimensional groups it may become
  handy to have different horizontal and vertical
  weights.
</descr>
<seealso>
  <link id="TMUIArea.Weight">Weight</link>
  <link id="TMUIArea.HorizWeight">HorizWeight</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIArea.InnerLeft">
<short>[i] Adjust the space between an object and its frame.</short>
<descr>Usually you shouldn't use this tag since you will override the users preferred default setting.
</descr>
<seealso>
  <link id="TMUIArea.Frame">Frame</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIArea.InnerTop">
<short>[i] Adjust the space between an object and its frame.</short>
<descr>Usually you shouldn't use this tag since you will override the users preferred default setting.
</descr>
<seealso>
  <link id="TMUIArea.Frame">Frame</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIArea.InnerRight">
<short>[i] Adjust the space between an object and its frame.</short>
<descr>Usually you shouldn't use this tag since you will override the users preferred default setting.
</descr>
<seealso>
  <link id="TMUIArea.Frame">Frame</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIArea.InnerBottom">
<short>[i] Adjust the space between an object and its frame.</short>
<descr>Usually you shouldn't use this tag since you will override the users preferred default setting.
</descr>
<seealso>
  <link id="TMUIArea.Frame">Frame</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIArea.InputMode">
<short>[i] Defines how the item react to user input</short>
<descr>
<p>efinition of reaction to user input:</p>
<dl>
  <dt>MUIV_InputMode_None</dt><dd>No input, this is not a gadget.</dd>
  <dt>MUIV_InputMode_RelVerify</dt><dd>Item pressed down as long the mouse is pressed, up when Mouse is realeased. For buttons and similar stuff. </dd>
  <dt>MUIV_InputMode_Immediate</dt><dd>Item changed the selection status to selected when clicked. Used e.g. in a radio button object.</dd>
  <dt>MUIV_InputMode_Toggle</dt><dd>Item toggles its selection status when clicked. For things like checkmark gadgets.</dd>
</dl>
</descr>
<seealso>
  <link id="TMUIArea.Selected">Selected</link>
  <link id="TMUIArea.Pressed">Pressed</link>
  <link id="TMUIArea.OnClick">OnClick</link>
  <link id="TMUIArea.OnSelected">OnSelected</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIArea.MaxHeight">
<short>[i] Specify a maximum height for an object (in pixels).</short>
</element>

<!-- property Visibility: published -->
<element name="TMUIArea.MaxWidth">
<short>[i] Specify a maximum width for an object (in pixels).</short>
</element>

<!-- property Visibility: published -->
<element name="TMUIArea.Selected">
<short>Get and set the selected state of a gadget.</short>
<descr>
<p>
This attribute can be triggered by the user
clicking on the gadget (or using the keyboard),
depending on the input mode:</p>
<dl>
  <dt>MUIV_InputMode_None</dt><dd><ul><li>set when lmb is pressed.</li>
           <li>cleared when lmb is released.</li>
           <li>cleared when the gadget is selected and the
              mouse leaves the gadget box.</li>
           <li>set when the mouse reenters the gadget box.</li></ul></dd>
  <dt>MUIV_InputMode_RelVerify</dt><dd>Item pressed down as long the mouse is pressed, up when Mouse is realeased. For buttons and similar stuff. </dd>
  <dt>MUIV_InputMode_Immediate</dt><dd>Item changed the selection status to selected when clicked. Used e.g. in a radio button object.</dd>
  <dt>MUIV_InputMode_Toggle</dt><dd>Item toggles its selection status when clicked. For things like checkmark gadgets.</dd>
</dl>
</descr>
<seealso>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIArea.ShortHelp">
<short>Specify a string that is to be used as bubble help for this
        object.</short>
<descr>
</descr>
</element>

<!-- property Visibility: published -->
<element name="TMUIArea.ShowSelState">
<short>[i] Invert the Frame border when item is selected</short>
<descr>
Normally a gadget will reverse its frame and
display the configured MUII_SelectedBack background
pattern in its selected state. For some objects
(e.g. checkmarks) this is not recommended and
can be supressed by setting ShowSelState
to False.
</descr>
<seealso>
   <link id="TMUIArea.Selected">Selected</link>
</seealso>
</element>


<!-- property Visibility: published -->
<element name="TMUIArea.ShowMe">
<short>Objects with this attribute set are not displayed.</short>
<descr>
Objects with this attribute set are not displayed. You can
set ShowMe at any time, causing objects to appear and
to disappear immediately. A new layout is calculated whenever
some objects are shown or hidden. When necessary, MUI will
resize the parent window to make place for the new objects.
Defaults to True.
</descr>
</element>

<!-- property Visibility: published -->
<element name="TMUIArea.Weight">
<short>The weight of an object determines how much room it will get during the layout process.</short>
<descr>
<p>This tag is a shorthand for <link id="TMUIArea.HorizWeight">HorizWeight</link> and
<link id="TMUIArea.VertWeight">VertWeight</link>, it sets both weights at once.</p>
<p>Imagine you have
a 100 pixel wide horizontal group with two string
gadgets. Usually, each gadget will get half of the
room and be 50 pixels wide. If you feel the left
gadget is more important and should be bigger,
you can give it a weight of 200 (and 100 for
the right gadget). Because the left gadget is
twice as "heavy" as the right gadget, it will
become twice as big (about 66 pixel) as the
right one (34 pixel).</p>
<p>Of course giving weights only makes sense if the
object is resizable. A <link id="TMUIArea.VertWeight">VertWeight</link> for a
(always fixed height) string gadget is useless.</p>
<p>An object with a weight of 0 will always stay at its minimum size.</p>
<p> By default, all objects have a weight of 100.</p>
</descr>
<seealso>
  <link id="TMUIArea.HorizWeight">HorizWeight</link>
  <link id="TMUIArea.VertWeight">VertWeight</link>
</seealso>
</element>

<element name="TMUIArea.ObjectID">
<short>
  Objects with a ObjectID &lt;&gt;0 export their
  contents during <link id="TMUIApplication.Save">MUIApp.Save()</link> and import
  them during <link id="TMUIApplication.Load">MUIApp.Load()</link>.
  You have to use different ExportIDs for your objects!
</short>
</element>

<!-- property Visibility: published -->
<element name="TMUIArea.OnSelected">
<short>Event when Item is clicked and in <link id="TMUIArea.InputMode">InputMode</link> = MUIV_InputMode_Immediate or MUIV_InputMode_Toggle </short>
<descr>
<p>Mainly use for Radio button and CheckBoxes. The event reacts on change of <link id="TMUIArea.Selected">Selected</link> </p>
</descr>
<seealso>
  <link id="TMUIArea.InputMode">InputMode</link>
  <link id="TMUIArea.Selected">Selected</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIArea.OnClick">
<short>Event when Item is selected and in <link id="TMUIArea.InputMode">InputMode</link> = MUIV_InputMode_RelVerify </short>
<descr>
<p>Mainly use for Buttons to check when the Button is clicked. The event reacts on the release of <link id="TMUIArea.Pressed">Pressed</link> </p>
</descr>
<seealso>
  <link id="TMUIArea.InputMode">InputMode</link>
  <link id="TMUIArea.Pressed">Pressed</link>
</seealso>
</element>

<!-- class Visibility: default -->
<element name="TMUIRectangle">
<short>Create an empty Rectangle object</short>
<descr>
Rectangle class seems kind of useless since it
doesn't define any attributes or methods itself.
However, objects of this type are frequently
used in every application. They allow insertion
of space to control MUI's layout process.
</descr>
</element>

<!-- procedure Visibility: protected -->
<element name="TMUIRectangle.GetCreateTags">
<short>Form the TagList for creation of a rectangle item</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIRectangle.GetCreateTags.ATagList">
<short>Taglist to be formed</short>
</element>

<!-- constructor Visibility: public -->
<element name="TMUIRectangle.Create">
<short>Create the object and init the default values</short>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIRectangle.CreateObject">
<short>Create the MUI Item</short>
</element>

<!-- property Visibility: published -->
<element name="TMUIRectangle.BarTitle">
<short>[i] Text inside a horizontal bar</short>
<descr>
This attribute describes a text string which will be displayed
in group title style centered in the rectangle. Really only
makes sense if <link id="TMUIRectangle.HBar">HBar</link> is True.
</descr>
<seealso>
  <link id="TMUIRectangle.HBar">HBar</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIRectangle.HBar">
<short>[i] Draws a horizontal bar in the middle of the rectangle</short>
<descr>
When set to True, MUI draws a horizontal bar in the middle of the
rectangle. Such bars can be used instead of group frames to
seperate objects in a window.
</descr>
<seealso>
  <link id="TMUIRectangle.VBar">VBar</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIRectangle.VBar">
<short>[i] Draws a vertical bar in the middle of the rectangle</short>
<descr>
When set to True, MUI draws a vertical bar in the middle of the
rectangle. Such bars can be used instead of group frames to
seperate objects in a window.
</descr>
<seealso>
  <link id="TMUIRectangle.HBar">HBar</link>
</seealso>
</element>

<!-- class Visibility: default -->
<element name="TMUIBalance">
<short>Splitter type item to change sizes of to aligned object</short>
<descr>
The balance class is very simple and has no attributes.
Simply insert objects of this class somewhere in your
group (only horizontal or vertical groups, nothing
2-dimensional) allows your users to dynamically change
the weight of your children.
</descr>
</element>

<!-- procedure Visibility: protected -->
<element name="TMUIBalance.GetCreateTags">
<short>Fill Tag list to create a blanace item</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIBalance.GetCreateTags.ATagList">
<short>Taglist to fill</short>
</element>

<!-- constructor Visibility: public -->
<element name="TMUIBalance.Create">
<short>Create the Balance object</short>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIBalance.CreateObject">
<short>Create the MUI balance Item</short>
</element>

<!-- property Visibility: published -->
<element name="TMUIBalance.Quiet">
<short>[i] Only show Frame when mouse hovers over it</short>
</element>

<!-- class Visibility: default -->
<element name="TMUIGauge">
<short>Progressbar like item</short>
<descr>
A gauge object is a nice looking display element useful
for some kind of progress display.
</descr>
</element>

<!-- procedure Visibility: protected -->
<element name="TMUIGauge.GetCreateTags">
<short>Fill TagList with Tags to create gauge item</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIGauge.GetCreateTags.ATagList">
<short>TagList to fill</short>
</element>

<!-- constructor Visibility: public -->
<element name="TMUIGauge.Create">
<short>Create a Gauge object</short>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIGauge.CreateObject">
<short>Create the MUI Gauge item</short>
</element>

<!-- property Visibility: published -->
<element name="TMUIGauge.Current">
<short>Set the current level of the gauge</short>
<descr>
  The value must be between 0 and <link id="TMUIGauge.Max">Max</link>.
</descr>
<seealso>
  <link id="TMUIGauge.Max">Max</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIGauge.Divide">
<short>Divide the Value for display</short>
<descr>
If this attribute is &lt;&gt; 0, every value set with
<link id="TMUIGauge.Current">Current</link> will be divided by this before
further processing.
</descr>
<seealso>
  <link id="TMUIGauge.Current">Current</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIGauge.InfoText">
<short>Text in the progressbar</short>
<descr>
  <p>
    The text given here is displayed within a gauge object
    and is usually intended to show some kind of percentage
    information.
  </p>
  <p>
    This texts preparse is set to #27'c'#27'8', this makes
    it appear centered and highlighted by default.
  </p>
  <p>
    Any %ld will be replaced with the current value of
    <link id="TMUIGauge.Current">Current</link>.
  </p>
</descr>
<seealso>
  <link id="TMUIGauge.Current">Current</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIGauge.Max">
<short>Maximum of the Gauge</short>
<descr>
  Set the maximum value for the gauge.
  Defaults to 100.
  Currently, <link id="TMUIGauge.Max">Max</link> and <link id="TMUIGauge.Current">Current</link>
  is limited to 16 bit.
</descr>
<seealso>
  <link id="TMUIGauge.Max">Max</link>
  <link id="TMUIGauge.Current">Current</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIGauge.Horiz">
<short>make the Gauge horizontal </short>
<descr>
  Determine if you want a horizontal or vertical gauge.
  Default to False (= vertical Gauge)
</descr>
<seealso>
  <link id="TMUIGauge.Current">Current</link>
</seealso>
</element>

<!-- class Visibility: default -->
<element name="TMUIScale">
<short>Percentage Scale</short>
<descr>
  <p>
    A Scale object generates a percentage scale
    running from 0% to 100%. A good place for
    such an object is e.g. below a fuel <link id="TMUIGauge">gauge</link>.
  </p>
  <p>
    Depending on how much space is available,
    the scale will be more or less detailed.
  </p>
  <p>
    Due to MUI's automatic layout system, you
    don't need to worry about it's size. When
    placed in a vertical group just below the
    object you want to scale, everything is
    fine.
  </p>
</descr>
<seealso>
  <link id="TMUIGauge">gauge</link>
</seealso>
</element>

<!-- procedure Visibility: protected -->
<element name="TMUIScale.GetCreateTags">
<short>Fill Tag list to create the Scale item</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIScale.GetCreateTags.ATagList">
<short>Tag list to fill</short>
</element>

<!-- constructor Visibility: public -->
<element name="TMUIScale.Create">
<short>Create Scale object</short>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIScale.CreateObject">
<short>Create the MUI item</short>
</element>

<!-- property Visibility: published -->
<element name="TMUIScale.Horiz">
<short>Show the scale in teh horizontal direction</short>
<descr>
  Indicate whether you want a horizontal or a
  vertical scale.
  <b>Currently, only the horizontal scale is implemented.</b>
  Defaults to True.
</descr>
</element>

<!-- class Visibility: default -->
<element name="TMUIColorfield">
<short></short>
<descr>
</descr>
<errors>
</errors>
<seealso>
</seealso>
</element>

<!-- procedure Visibility: protected -->
<element name="TMUIColorfield.GetCreateTags">
<short>Fill TagList to create the Colorfield item</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIColorfield.GetCreateTags.ATagList">
<short>TagList to fill</short>
</element>

<!-- constructor Visibility: public -->
<element name="TMUIColorfield.Create">
<short>Create a Colorfield object</short>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIColorfield.CreateObject">
<short>Create the MUI item</short>
</element>

<!-- property Visibility: public -->
<element name="TMUIColorfield.Pen">
<short>Use this Pen to show the color</short>
<descr>
When specified, the colorfield uses exactly this pen instead
of trying to obtain a new one.
</descr>
<seealso>
  <link id="TMUIColorfield.RGB">RGB</link>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TMUIColorfield.RGB">
<short>Set or Get Color as three 32bit LongWords</short>
<descr>
Set or get the red/green/blue values of a colorfield all at
once. You pass in / receive a pointer to three longwords
containing the 32-bit red, green and blue values.
</descr>
<seealso>
  <link id="TMUIColorfield.Red">Red</link>
  <link id="TMUIColorfield.Green">Green</link>
  <link id="TMUIColorfield.Blue">Blue</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIColorfield.Blue">
<short>Blue color component as 32bit LongWord</short>
<descr>
Set or get the 32-bit blue component of the fields color.
Values range from 0 (no blue) to $ffffffff (full blue).
</descr>
<seealso>
  <link id="TMUIColorfield.Red">Red</link>
  <link id="TMUIColorfield.Green">Green</link>
  <link id="TMUIColorfield.RGB">RGB</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIColorfield.Red">
<short>Red color component as 32bit LongWord</short>
<descr>
Set or get the 32-bit red component of the fields color.
Values range from 0 (no red) to $ffffffff (full red).
</descr>
<seealso>
  <link id="TMUIColorfield.RGB">RGB</link>
  <link id="TMUIColorfield.Green">Green</link>
  <link id="TMUIColorfield.Blue">Blue</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIColorfield.Green">
<short>Green color component as 32bit LongWord</short>
<descr>
Set or get the 32-bit green component of the fields color.
Values range from 0 (no green) to $ffffffff (full green).
</descr>
<seealso>
  <link id="TMUIColorfield.Red">Red</link>
  <link id="TMUIColorfield.RGB">RGB</link>
  <link id="TMUIColorfield.Blue">Blue</link>
</seealso>
</element>

<!-- class Visibility: default -->
<element name="TMUIText">
<short>Label type text object</short>
<descr>
Text class allows generating objects that contain
some kind of text. You can control the outfit of
your text with some special control characters,
including italics, bold, underline and color
codes. Format codes align text either left,
centered or right, linefeeds allow multiline
text fields.
</descr>
<seealso>
  <link id="MUIClass.List.TMUIFloatText">FloatText</link>
</seealso>
</element>

<!-- procedure Visibility: protected -->
<element name="TMUIText.GetCreateTags">
<short>Fill Tags list for Text item creation</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIText.GetCreateTags.ATagList">
<short>TagList to fill</short>
</element>

<!-- constructor Visibility: public -->
<element name="TMUIText.Create">
<short>Create Text object</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIText.Create.AContents">
<short>String to be displayed in a text object.</short>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIText.CreateObject">
<short>Create the MUI item</short>
</element>

<!-- property Visibility: published -->
<element name="TMUIText.Contents">
<short>String to be displayed in a text object.</short>
<descr>
<p>If the string is larger than available display space,
it will be clipped. Setting Contents to ''
results in an empty text object.</p>
<p>The string is copied into a private buffer, you can destroy
the original after using this tag.
</p>
<p>
whenever MUI prints strings, they may contain some special
character sequences defining format, color and style of the text.
</p>
<dl>
  <dt>'\n'</dt><dd>Start a new line. With this character you can e.g. create multi line buttons.</dd>
  <dt>ESC -</dt><dd>Disable text engine, following chars will be printed without further parsing.</dd>
  <dt>ESC u</dt><dd>Set the soft style to underline.</dd>
  <dt>ESC b</dt><dd>Set the soft style to bold.</dd>
  <dt>ESC i</dt><dd>Set the soft style to italic.</dd>
  <dt>ESC n</dt><dd>Set the soft style back to normal.</dd>
  <dt>ESC &lt;n&gt;</dt><dd>Use pen number n (2..9) as front pen. n must be a valid DrawInfo pen as specified in intuition".</dd>
  <dt>ESC c</dt><dd>Center current (and following) line(s). This sequence is only valid at the beginning of a string or after a newline character.</dd>
  <dt>ESC r</dt><dd>Right justify current (and following) line(s). This sequence is only valid at the beginning of a string or after a newline character.</dd>
  <dt>ESC l</dt><dd>Left justify current (and following) line(s). This sequence is only valid at the beginning of a string or after a newline character.</dd>
  <dt>ESC I[s]</dt><dd>Draw MUI image with specification &lt;s&gt;. See <link id="MUIClass.Image.TMUIImage.Spec">image</link> for image spec definition.</dd>
</dl>
</descr>
<seealso>
  <link id="TMUIText.SetMin">SetMin</link>
  <link id="TMUIText.SetMax">SetMax</link>
  <link id="TMUIText.PreParse">PreParse</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIText.HiChar">
<short>[i] Underline this character in the Text</short>
<descr>
If the character given here exists in the displayed
string (no matter if upper or lower case), it will
be underlined. This makes it easy to create macros
such as KeyButton() that specify the control char
and the underline char at the same time.
</descr>
<seealso>
  <link id="TMUIText.Contents">Contents</link>
  <link id="TMUIArea.ControlChar">ControlChar</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIText.PreParse">
<short>Define fixed content independant text format.</short>
<descr>
<p>
String containing format definitions to be parsed before
the text from <link id="TMUIText.Contents">Contents</link> is printed.
</p>
<p>
Using this tag, you can easily define different formats,
colors and styles without modifying the original string.
</p>
</descr>
<seealso>
  <link id="TMUIText.Contents">Contents</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIText.SetMax">
<short>[i] Define the initial contents width as maximum width of the item</short>
<descr>
<p>
Boolean value to indicate wether the objects maximal width
shall be calculated to fit the string given with
<link id="TMUIText.Contents">Contents</link>.
</p>
<p>
When set to False, maximum width is not limited.
</p>
<p>
For a text object that needs to be updated (e.g. some
information about your programs status) you would probably
set SetMax to False to allow resizing of this
object.
</p>
<p>
For a label for one of your gadgets, you might want to
give this property a value of True to prevent MUI from
inserting additional layout space.
</p>
<p>
Default to False
</p>
</descr>
<seealso>
  <link id="TMUIText.Contents">Contents</link>
  <link id="TMUIText.SetMin">SetMin</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIText.SetMin">
<short>[i] Define the initial contents width as minimum width of the item</short>
<descr>
<p>
Boolean value to indicate wether the objects minimal width
shall be calculated to fit the string given with
<link id="TMUIText.Contents">Contents</link>.
</p>
<p>
When set to False, minimum width will be set to 0
and the displayed string may be clipped.
</p>
<p>Defaults to True.</p>
</descr>
<seealso>
  <link id="TMUIText.Contents">Contents</link>
  <link id="TMUIText.SetMax">SetMax</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIText.SetVMax">
<short>[i] Fix Vertical height</short>
<descr>
Settings this to False makes a TextObjects y-size unlimited.
Defaults to True which means the objects height is fixed.
</descr>
<seealso>
  <link id="TMUIText.Contents">Contents</link>
  <link id="TMUIText.SetMax">SetMax</link>
</seealso>
</element>

<!-- class Visibility: default -->
<element name="TMUIPenDisplay">
<short>Show a Pen as Color field</short>
<descr>
Pendisplay class takes a struct PMUI_PenSpec and displays it.
Its main use is to be sub-classed by Poppen class which adds
a popup window to adjust the PMUI_PenSpec. <link id="TMUIPopPen">PopPen</link> class should
be used by every application that allows users to configure
custom drawing pens.
</descr>
<seealso>
  <link id="TMUIPopPen">PopPen</link>
</seealso>
</element>

<!-- procedure Visibility: protected -->
<element name="TMUIPenDisplay.GetCreateTags">
<short>Fill Tag list for PenDisplay creation</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIPenDisplay.GetCreateTags.ATagList">
<short>TagList to fill</short>
</element>

<!-- procedure Visibility: protected -->
<element name="TMUIPenDisplay.AfterCreateObject">
<short>Connects events after MUI item is created</short>
</element>

<!-- constructor Visibility: public -->
<element name="TMUIPenDisplay.Create">
<short>Creates a PenDisplay Object</short>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIPenDisplay.CreateObject">
<short>Creates the MUI item</short>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIPenDisplay.SetColormap">
<short>Switch the pendisplay object to a specific colormap entry.</short>
<seealso>
  <link id="TMUIPenDisplay.SetMUIPen">SetMUIPen</link>
  <link id="TMUIPenDisplay.SetRGB">SetRGB</link>
  <link id="TMUIPenDisplay.SetRGB">SetRGB</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TMUIPenDisplay.SetColormap.ColorMap">
<short>Colormap entry</short>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIPenDisplay.SetMUIPen">
<short>Switch the pendisplay object to a specific MUI pen (MPEN_SHINE, MPEN_SHADOW, ...)</short>
<seealso>
  <link id="TMUIPenDisplay.SetColormap">SetMUIPen</link>
  <link id="TMUIPenDisplay.SetRGB">SetRGB</link>
  <link id="TMUIPenDisplay.SetRGB">SetRGB</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TMUIPenDisplay.SetMUIPen.MUIPen">
<short>MUI Pen to set</short>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIPenDisplay.SetRGB">
<short>Switch the pendisplay object to an RGB value.</short>
<seealso>
  <link id="TMUIPenDisplay.SetMUIPen">SetMUIPen</link>
  <link id="TMUIPenDisplay.SetColormap">SetMUIPen</link>
  <link id="TMUIPenDisplay.SetRGB8">SetRGB8</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TMUIPenDisplay.SetRGB.Red">
<short>Red component as 32 bit longword</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIPenDisplay.SetRGB.Green">
<short>Green component as 32 bit longword</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIPenDisplay.SetRGB.Blue">
<short>Blue component as 32 bit longword</short>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIPenDisplay.SetRGB8">
<short>Switch the pendisplay object to an RGB value as byte values.</short>
<descr>
</descr>
<errors>
</errors>
<seealso>
  <link id="TMUIPenDisplay.SetMUIPen">SetMUIPen</link>
  <link id="TMUIPenDisplay.SetColormap">SetMUIPen</link>
  <link id="TMUIPenDisplay.SetRGB">SetRGB</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TMUIPenDisplay.SetRGB8.Red">
<short>Red component as byte value</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIPenDisplay.SetRGB8.Green">
<short>Green component as byte value</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIPenDisplay.SetRGB8.Blue">
<short>Blue component as byte value</short>
</element>

<!-- property Visibility: public -->
<element name="TMUIPenDisplay.Pen">
<short>Used Pen for this item</short>
<descr>
<p>This attribute returns the
pen number MUI uses for color representation of the current
pendisplay object.</p>
<p>This attribute returns -1 when outside of not setup
or when the pendisplay object didnt allocate a color on its
own.
</p>
</descr>
<seealso>
  <!--link id="TMUIPenDisplay.Reference">TMUIPenDisplay.Reference</link-->
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TMUIPenDisplay.Spec">
<short>Defines the color/pen to show</short>
<descr>
<p>
The black box structure PMUI_PenSpec specifies a drawing
pen which should be displayed by Pendisplay class. If you
use Poppen class to allow your users to configure custom
drawing pens, its this attribute that you need to get()
and save in your preferences.</p>
<p>
Use the functions MUI_ObtainPen() and MUI_ReleasePen()
from muimaster.library and the MUIPEN() macro to get
a usable value for SetAPen() from a struct MUI_PenSpec.</p>
<p>
<b>NOTE</b>: In allmost all cases you will use <link id="TMUIPopPen">PopPen</link> class which
is a subclass of Pendisplay class. </p>
</descr>
<seealso>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIPenDisplay.OnSpecChange">
<short>Color definition was changed</short>
<descr>
  The <link id="TMUIPenDisplay.Spec">Spec</link> field was changed. useful for
  <link id="TMUIPopPen">PopPen</link> where the user can change the pen with a dialog.
</descr>
<seealso>
  <link id="TMUIPenDisplay.Spec">Spec</link>
  <link id="TMUIPopPen">PopPen</link>
</seealso>
</element>

<!-- class Visibility: default -->
<element name="TMUIPopPen">
<short>Colored Button with Dialog to choose a Color/Pen</short>
<descr>
<p>
Poppen class adds input capabilities to its super class
Pendisplay. It should be used if your application allows
users to configure some custom pens for rendering.
</p>
<p>
A Poppen object will appear as kind of a button which
displays the currently selected color. When the user hits
the button, a Popup window containing a Penadjust object
opens up and lets the user choose change the color.</p>
<p>
You can control the window title of the popup window using
the <link id="TMUIPopPen.WinTitle">WinTitle</link> field. It will remember
its value and use it when creating the popup window.</p>
<p>
As most MUI popups, the Penadjust popup window runs
asynchronously and stays there until the user terminates
it with "OK" or "Cancel". Furthermore, if the popup window
is automatically cancelled if the pop button is removed.</p>
<p> You
can get/set the current color from a Poppen object by using
the <link id="TMUIPenDisplay.Spec">Spec</link> attribute. The resulting struct
PMUI_SpenSpec may then be saved somewhere in your preferences
and used as parameter for MUI_ObtainPen() and MUI_ReleasePen().
</p>
</descr>
<errors>
</errors>
<seealso>
  <link id="TMUIPopPen.WinTitle">WinTitle</link>
  <link id="TMUIPenDisplay.Spec">Spec</link>
</seealso>
</element>


<!-- procedure Visibility: protected -->
<element name="TMUIPopPen.GetCreateTags">
<short>Fill Tag list for PopPen creation</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIPopPen.GetCreateTags.ATagList">
<short>TagList to fill</short>
</element>

<!-- constructor Visibility: public -->
<element name="TMUIPopPen.Create">
<short>Creates a PopPen Object</short>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIPopPen.CreateObject">
<short>Create the PopPen object</short>
</element>

<!-- property Visibility: published -->
<element name="TMUIPopPen.WinTitle">
<short>Define the title of the Dialog window</short>
</element>

<!-- class Visibility: default -->
<element name="TMUIButton">
<short>Short cut to create a simple Button</short>
</element>

<!-- constructor Visibility: public -->
<element name="TMUIButton.Create">
<short>Create a Button object</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIButton.Create.ATitle">
<short>Define the Text on the Button</short>
</element>

<!-- class Visibility: default -->
<element name="TMUIHSpace">
<short>Horizontal space object</short>
</element>

<!-- constructor Visibility: public -->
<element name="TMUIHSpace.Create">
<short>Create the horizontal space object</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIHSpace.Create.Space">
<short>Number of pixels height</short>
</element>

<!-- class Visibility: default -->
<element name="TMUIVSpace">
<short>Vertical space object</short>
</element>

<!-- constructor Visibility: public -->
<element name="TMUIVSpace.Create">
<short>Create the vertical space object</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIVSpace.Create.Space">
<short>Number of Pixels width</short>
</element>

<!-- class Visibility: default -->
<element name="TMUIHBar">
<short>Horizonal bar object</short>
</element>

<!-- constructor Visibility: public -->
<element name="TMUIHBar.Create">
<short>Create a horizontal bar</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIHBar.Create.Space">
<short>Number of Pixels height</short>
</element>

<!-- class Visibility: default -->
<element name="TMUIVBar">
<short>Vertical bar object</short>
</element>

<!-- constructor Visibility: public -->
<element name="TMUIVBar.Create">
<short>Create a vertical bar object</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIVBar.Create.Space">
<short>Number of pixels width</short>
</element>

<!-- class Visibility: default -->
<element name="TMUIBarTitle">
<short>Horizontal bar with a Text</short>
</element>

<!-- constructor Visibility: public -->
<element name="TMUIBarTitle.Create">
<short>Create horizontal bar with text</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIBarTitle.Create.ALabel">
<short>Text shown in the bar object</short>
</element>

<!-- constructor Visibility: public -->
<element name="TSpecDesc.Create">
<short>Create a Spec description object</short>
</element>

<!-- procedure Visibility: public -->
<element name="TSpecDesc.SetStdPattern">
<short>Set by MUI standard pattern (will directly supplied not as string)</short>
<seealso>
  <link id="MUIClass.Image.TMUIImage.Spec">TMUIImage.Spec</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TSpecDesc.SetStdPattern.APattern">
<short>e.g. MUII_BACKGROUND ... MUII_FILLBACK2 , MUII_ButtonBack, MUII_TextBack</short>
</element>

<!-- procedure Visibility: public -->
<element name="TSpecDesc.SetRGB">
<short>Set by Color as three bytes</short>
<descr>
  will resolve to '2: rrrrrrrr,gggggggg,bbbbbbbb'
</descr>
<seealso>
  <link id="TSpecDesc.SetRGB32">SetRGB32</link>
  <link id="MUIClass.Image.TMUIImage.Spec">TMUIImage.Spec</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TSpecDesc.SetRGB.R">
<short>Red as byte</short>
</element>

<!-- argument Visibility: default -->
<element name="TSpecDesc.SetRGB.G">
<short>Green as byte</short>
</element>

<!-- argument Visibility: default -->
<element name="TSpecDesc.SetRGB.B">
<short>Blue as byte</short>
</element>

<!-- procedure Visibility: public -->
<element name="TSpecDesc.SetRGB32">
<short>Set by Color MUI typical as three Longwords</short>
<descr>
  will resolve to '2: rrrrrrrr,gggggggg,bbbbbbbb'
</descr>
<seealso>
  <link id="TSpecDesc.SetRGB">SetRGB</link>
  <link id="MUIClass.Image.TMUIImage.Spec">TMUIImage.Spec</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TSpecDesc.SetRGB32.R">
<short>Red component as LongWord</short>
</element>

<!-- argument Visibility: default -->
<element name="TSpecDesc.SetRGB32.G">
<short>Green component as LongWord</short>
</element>

<!-- argument Visibility: default -->
<element name="TSpecDesc.SetRGB32.B">
<short>Blue component as LongWord</short>
</element>

<!-- procedure Visibility: public -->
<element name="TSpecDesc.SetBoopsiName">
<short>Set by external Boopsi class name</short>
<descr>
  will resolve to '3: &lt;AName&gt;'
</descr>
<seealso>
  <link id="MUIClass.Image.TMUIImage.Spec">TMUIImage.Spec</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TSpecDesc.SetBoopsiName.AName">
<short>Name of the external Boopsi class</short>
</element>

<!-- procedure Visibility: public -->
<element name="TSpecDesc.SetMUIBrush">
<short>Set by external MUI brush name</short>
<descr>
  will resolve to '4: &lt;AName&gt;'
</descr>
<seealso>
  <link id="MUIClass.Image.TMUIImage.Spec">TMUIImage.Spec</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TSpecDesc.SetMUIBrush.AName">
<short>Name of the external MUI brush</short>
</element>

<!-- procedure Visibility: public -->
<element name="TSpecDesc.SetPicture">
<short>Set by path to an external Picture</short>
<descr>
  will resolve to '5: &lt;PicPath&gt;'
  Picture will be loaded by datatype
</descr>
<seealso>
  <link id="MUIClass.Image.TMUIImage.Spec">TMUIImage.Spec</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TSpecDesc.SetPicture.PicPath">
<short>Name of the picture with path</short>
</element>

<!-- procedure Visibility: public -->
<element name="TSpecDesc.SetPreConf">
<short>Set by preconfigured patterns</short>
<descr>
  MUII_WindowBack ... MUII_Count - 1
  will resolve to '6: &lt;ABack&gt;'
</descr>
<seealso>
  <link id="MUIClass.Image.TMUIImage.Spec">TMUIImage.Spec</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TSpecDesc.SetPreConf.ABack">
<short>Value of the preconfigures pattern</short>
</element>

<!-- procedure Visibility: public -->
<element name="TSpecDesc.SetString">
<short>Set by a string</short>
<descr>
  The string must begin with a number and colon '&lt;n&gt;: &lt;parameter&gt;'
  Check <link id="MUIClass.Image.TMUIImage.Spec">TMUIImage.Spec</link> for more informations.
</descr>
<seealso>
  <link id="MUIClass.Image.TMUIImage.Spec">TMUIImage.Spec</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TSpecDesc.SetString.AText">
<short>Text to set as Spec description</short>
</element>

<!-- property Visibility: public -->
<element name="TSpecDesc.IsSet">
<short>defines if the Value was set at least once with one of the set functions</short>
</element>

<!-- property Visibility: published -->
<element name="TSpecDesc.Spec">
<short>Spec value as it will be written to the MUI Field</short>
</element>

<!-- function Visibility: default -->
<element name="ColCompToMUI">
<short>Convert a Byte Color component to a 32 bit MUI Longword Color component</short>
<descr>
  MUI uses 32bit LongWord for each color component for (0 = no color $ffffffff = full color) this converts the
  standard bytes to the MUI LongWords by filling up the rest of the longword:
  for example: byte = $42 ; LongWord $42424242
</descr>
<seealso>
  <link id="MUIToColComp">MUIToColComp()</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="ColCompToMUI.Result">
<short>Color Component as LongWord for MUI</short>
</element>

<!-- argument Visibility: default -->
<element name="ColCompToMUI.c">
<short>Color Component as Byte</short>
</element>

<!-- function Visibility: default -->
<element name="MUIToColComp">
<short>Convert a MUI LongWord Color component to a standard Byte Color component</short>
<descr>
  MUI uses 32bit LongWord for each color component for (0 = no color $ffffffff = full color) this converts the
  MUI LongWords to standard bytes by cutting away the not needed bits :
  for example: LongWord = $421bc512 ; byte = $42
</descr>
<seealso>
  <link id="ColCompToMUI">ColCompToMUI()</link>
</seealso>
</element>

<!-- function result Visibility: default -->
<element name="MUIToColComp.Result">
<short>Color component as byte</short>
</element>

<!-- argument Visibility: default -->
<element name="MUIToColComp.c">
<short>Color Component as MUI LongWord</short>
</element>

</module> <!-- MUIClass.Area -->

</package>
</fpdoc-descriptions>
